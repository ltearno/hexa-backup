<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Hexa-Backup Store</title>
    <base href="/public">
    <script src="/public/mime-types.js"></script>
    <style>
        body {
            position: absolute;
            top: 0px;
            left: 0;
            right: 0;
            bottom: 0;
            margin: 0;
            padding: 0;

            display: flex;
            overflow-x: auto;
        }

        #directoryContent {
            display: flex;
        }

        #menu{
            overflow: auto;
            flex-grow: 0;
            flex-shrink: 0;
            padding:.5em;
        }

        #menu.hide-optional > #optional {
            display:none;
        }

        #directories,
        #files {
            font-family: monospace;
            overflow: auto;
            flex-grow: 0;
            flex-shrink: 0;
            padding:.5em;
        }

        .small {
            font-size: .8em;
            color: #333;
        }

        #images-container {
            overflow: auto;
            flex-grow: 1;
            min-width: 10em;

            height: 100vh;
            position: relative;
        }

        #images-container:-webkit-full-screen {
            /*display :block;
            width :100vh;*/
            height :100vw;
            max-width :inherit;
        }

        #image-full-container {
            overflow: auto;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        #images>div{
            display: inline-block;
        }

        .image-full{
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        img {
            image-orientation: from-image;
        }

        @media screen and (max-width: 1215px) {
            body {
                flex-flow: column;
            }

            #images-container {
                flex-shrink: 0;
            }

            #image-full-container {
                flex-shrink: 0;
            }

            img {
                width: 50vw;
            }

            #images {
                display: flex;
                flex-flow: row;
                flex-wrap: wrap;
                justify-content: space-around;
            }
        }
    </style>
</head>

<body>
    <div id="menu">
        <button id="fullScreen">full screen</button><br />
        <button onclick='el("#menu").classList.toggle("hide-optional")'>show/hide menu</button>

        <div id="optional">
            <h2>Sources</h2>
            <div id="refs-list"></div>

            <h2>Current</h2>
            <b><span id=refName></span></b><br><br>
            commit history
            <div id="commitHistory"></div>

            <h2>Settings</h2>
            <label>extended <input type="checkbox" id="extended"></label>

            <h2>Status</h2>
            <span id="status"></span>
        </div>
    </div>
    <div id="directories"></div>
    <div id="files"></div>
    <div id="images-container">
        <div id="images"></div>
    </div>
    <div id="image-full-container"></div>
</body>

<script>
    let EXTENDED = localStorage.getItem('EXTENDED') == 'true'

    let currentClientId = null
    let currentDirectoryDescriptorSha = null
    let currentPictureIndex = -1
    let imagesPool = []

    let displayedDirectoryDescriptorSha = null
    let displayedClientId = null
    let displayedPictureIndex = null

    const wait = (ms) => {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve()
            }, ms)
        })
    }

    let el = (id) => document.querySelector(id)

    const DATE_DISPLAY_OPTIONS = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    }
    const displayDate = date => (typeof date === 'number' ? new Date(date) : date).toLocaleString('fr', DATE_DISPLAY_OPTIONS)

    let lastPushedHistoryState = null
    const publishHistoryState = () => {
        let footprint = `${currentDirectoryDescriptorSha}#${currentClientId}`
        if (currentPictureIndex >= 0)
            footprint += `-${currentPictureIndex}`

        if (footprint != lastPushedHistoryState) {
            lastPushedHistoryState = footprint
            history.pushState({ currentDirectoryDescriptorSha, currentClientId, currentPictureIndex }, `directory ${currentDirectoryDescriptorSha}`, `/public/#${currentDirectoryDescriptorSha}${currentPictureIndex >= 0 ? `-${currentPictureIndex}` : ''}`)
        }
    }

    async function goDirectory(directoryDescriptorSha) {
        currentPictureIndex = -1
        currentDirectoryDescriptorSha = directoryDescriptorSha
        publishHistoryState()

        await syncUi()
    }

    async function goRef(ref) {
        let oldClientId = currentClientId
        currentClientId = ref
        if (currentClientId != oldClientId) {
            currentPictureIndex = -1
            currentDirectoryDescriptorSha = await getClientDefaultDirectoryDescriptorSha(ref)
        }
        publishHistoryState()

        await syncUi()
    }

    async function goPicture(index) {
        currentPictureIndex = index
        publishHistoryState()

        await syncUi()
    }

    async function goPreviousPicture() {
        if (currentPictureIndex <= 0)
            return

        currentPictureIndex--
        publishHistoryState()

        await syncUi()
    }

    async function goNextPicture() {
        if (currentPictureIndex < 0 || !imagesPool || !imagesPool.length || currentPictureIndex == imagesPool.length - 1)
            return

        currentPictureIndex++
        publishHistoryState()

        await syncUi()
    }

    async function goNoPicture() {
        currentPictureIndex = -1

        publishHistoryState()

        await syncUi()
    }

    let loaders = []

    let startLoading = (text) => {
        loaders.push(text)
        el('#status').innerHTML = loaders.join('<br>')
        return () => {
            loaders.splice(loaders.indexOf(text), 1)
            el('#status').innerHTML = loaders.join('<br>')
        }
    }

    async function showDirectory(directoryDescriptorSha) {
        el('#directories').innerHTML = ''
        el('#files').innerHTML = ''
        el('#images').innerHTML = ''

        if (!directoryDescriptorSha)
            return

        let finishLoading = startLoading(`loading directory descriptor ${directoryDescriptorSha.substr(0, 7)}`)
        let directoryDescriptor = await fetchDirectoryDescriptor(directoryDescriptorSha)
        finishLoading()

        if (!directoryDescriptor || !directoryDescriptor.files) {
            el('#directories').innerHTML = `error fetching ${directoryDescriptorSha}`
            return
        }

        let files = directoryDescriptor.files

        console.log(`entry files+dirs ${directoryDescriptorSha} = ${directoryDescriptor.files.length}`)

        finishLoading = startLoading(`listing directories`)
        let directoriesContent = files
            .filter(file => file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => EXTENDED ?
                `<div><span class='small'>${displayDate(file.lastWrite)} ${file.contentSha ? file.contentSha.substr(0, 7) : '-'}</span> <a href='#' onclick='event.preventDefault() || goDirectory("${file.contentSha}")'>${file.name}</a></div>` :
                `<div><a href='#' onclick='event.preventDefault() || goDirectory("${file.contentSha}")'>${file.name}</a></div>`)
        if (directoriesContent.length) {
            el('#directories').style.display = 'block'
            el('#directories').innerHTML = `<h2>${directoriesContent.length} Directories</h2>` + directoriesContent.join('')
        }
        else {
            el('#directories').style.display = 'none'
        }
        finishLoading()

        await wait(1)

        let images = []

        finishLoading = startLoading(`listing files`)
        let filesContent = files
            .filter(file => !file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => {
                let mimeTypes = ['application/octet-stream']
                let pos = file.name.lastIndexOf('.')
                if (pos >= 0) {
                    let extension = file.name.substr(pos + 1).toLocaleLowerCase()
                    if (extension in MimeTypes) {
                        mimeTypes.push(MimeTypes[extension])
                    }
                }

                let links = mimeTypes.map((mimeType, index) => `[<a href='/sha/${file.contentSha}/content?type=${mimeType}${index == 0 ? `&fileName=${file.name}` : ''}' >${EXTENDED ? mimeType : (index == 0 ? 'dl' : (mimeType.indexOf('/') ? mimeType.substr(mimeType.indexOf('/') + 1) : mimeType))}</a>]`).join(' ')

                let imageHtml = EXTENDED ?
                    `<span class='small'>${displayDate(file.lastWrite)} ${file.contentSha ? file.contentSha.substr(0, 7) : '-'}</span> ${file.name} <span class='small'>${file.size} ${links}</span>` :
                    `${file.name} <span class='small'>${links}</span>`

                mimeTypes.filter(t => t.startsWith('image/')).forEach(mimeType => {
                    images.push({ sha: file.contentSha, mimeType: mimeType, fileName: file.name })
                })

                return `<div>${imageHtml}</div>`
            })
        if (filesContent.length) {
            el('#files').style.display = 'block'
            el('#files').innerHTML = `<h2>${filesContent.length} Files</h2>` + filesContent.join('')
        }
        else {
            el('#files').style.display = 'none'
        }
        finishLoading()

        await wait(1)

        imagesPool = images
        restartImagesPool()
    }

    const maxImagesSeen = 100
    const imagesStep = 100

    let infiniteScrollerStop = null

    async function restartImagesPool() {
        if (infiniteScrollerStop) {
            infiniteScrollerStop()
            infiniteScrollerStop = null
        }

        if (imagesPool.length) {
            el('#images').innerHTML = ''
            infiniteScrollerStop = infiniteScroll(imagesPool,
                ({ sha, mimeType, fileName }, index) => `<div><img onclick='goPicture(${index})' src="/sha/${sha}/plugins/image/thumbnail?type=${mimeType}"/></div>`,
                el('#images-container'),
                el('#images'))
        }
        else {
            el('#images').innerHTML = '<br/><i class="small">no picture in this folder</i>'
            // <a href='/sha/${sha}/content?type=${mimeType}'></a>
        }
    }

    async function showPicture(index) {
        el('#image-full-container').innerHTML = ''
        if (index < 0)
            return
        let { sha, mimeType, fileName } = imagesPool[index]
        el('#image-full-container').innerHTML += `<div style='position:absolute;top:0;left:0;bottom:0;right:0;'><a style='width:100%;height:100%;display:flex;align-items:center;justify-content: center;' href='/sha/${sha}/content?type=${mimeType}'><img class='image-full' src='/sha/${sha}/content?type=${mimeType}'/></a></div>`
        el('#image-full-container').innerHTML += `<div style='position:absolute;bottom:0;left:0;right:0;padding:.5em;display:flex;justify-content:space-between;'><button style='font-size: 2em;' onclick='goPreviousPicture()'>&lt;</button><button style='font-size: 2em;' onclick='goNoPicture()'>X</button></div><button style='font-size: 2em;' onclick='goNextPicture()'>&gt;</button>`
    }

    async function getClientDefaultDirectoryDescriptorSha(ref) {
        if (!ref)
            return null

        let clientState = await (await fetch(`/refs/${ref}`)).json()
        if (!clientState)
            return null

        let commitSha = clientState.currentCommitSha
        if (commitSha == null)
            return null

        let finishLoading = startLoading(`loading commit for default directory descriptor`)

        let commit = await fetchCommit(commitSha)
        if (!commit)
            return null

        return commit.directoryDescriptorSha

        finishLoading()
    }

    async function showRef(ref) {
        el('#refName').innerText = ref || ''
        el('#commitHistory').innerHTML = ''

        if (!ref)
            return null

        let clientState = await (await fetch(`/refs/${ref}`)).json()
        if (!clientState)
            return null

        let commitSha = clientState.currentCommitSha
        let firstDirectoryDescriptorSha = null

        let finishLoading = startLoading(`loading commit history`)

        while (commitSha != null) {
            let commit = await fetchCommit(commitSha)
            if (!commit)
                break

            let date = new Date(commit.commitDate)
            let directoryDescriptorSha = commit.directoryDescriptorSha
            if (directoryDescriptorSha) {
                if (!firstDirectoryDescriptorSha)
                    firstDirectoryDescriptorSha = directoryDescriptorSha
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} ${displayDate(date)} - <a href='#' onclick='event.preventDefault() || goDirectory("${directoryDescriptorSha}")'>${directoryDescriptorSha.substr(0, 7)}</a></div>`
            } else {
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} no directory descriptor in commit !</div>`
            }

            commitSha = commit.parentSha
        }

        finishLoading()

        return firstDirectoryDescriptorSha
    }

    async function fetchCommit(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    async function fetchDirectoryDescriptor(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    function infiniteScroll(db, domCreator, scrollContainer, scrollContent) {
        let nextElementToInsert = 0
        let poolSize = 5
        let stopped = false
        let waitContinueResolver = null

        async function run() {
            const shouldAdd = () => scrollContent.lastChild.offsetTop - (scrollContainer.offsetHeight / 1) <= scrollContainer.scrollTop + scrollContainer.offsetHeight

            const scrollListener = event => {
                if (waitContinueResolver && shouldAdd()) {
                    let r = waitContinueResolver
                    waitContinueResolver = null
                    r()
                }
            }
            scrollContainer.addEventListener('scroll', scrollListener)

            stopped = false
            while (!stopped) {
                if (nextElementToInsert >= db.length)
                    break

                let index = nextElementToInsert++
                let elem = db[index]

                scrollContent.innerHTML += domCreator(elem, index)

                if (nextElementToInsert % poolSize == 0) {
                    await wait(150)

                    if (!shouldAdd())
                        await new Promise(resolve => waitContinueResolver = resolve)
                }
            }

            scrollContainer.removeEventListener('scroll', scrollListener)
        }

        function stop() {
            stopped = true
            if (waitContinueResolver) {
                waitContinueResolver()
                waitContinueResolver = null
            }
        }

        run()

        return stop
    }

    window.addEventListener('load', async () => {
        let resp = await fetch('/refs')
        let refs = (await resp.json()).filter(e => e.startsWith('CLIENT_')).map(e => e.substr(7))
        el('#refs-list').innerHTML = refs.map(ref => `<a href='#' onclick='event.preventDefault() || goRef("${ref}")'>${ref}</a>`).join('<br/>')
    })

    el('#fullScreen').addEventListener('click', () => {
        if (currentPictureIndex < 0)
            el('#images-container').webkitRequestFullScreen()
        else
            el('#image-full-container').webkitRequestFullScreen()
    })

    el('#extended').addEventListener('input', () => {
        EXTENDED = !!el('#extended').checked
        localStorage.setItem('EXTENDED', `${EXTENDED}`)

        syncUi()
    })

    window.onpopstate = function (event) {
        if (event.state) {
            currentDirectoryDescriptorSha = event.state.currentDirectoryDescriptorSha
            currentClientId = event.state.currentClientId
            currentPictureIndex = event.state.currentPictureIndex || 0

            syncUi()
        }
        else {
            fromHash()

            syncUi()
        }
    }

    if (history.state) {
        currentDirectoryDescriptorSha = history.state.currentDirectoryDescriptorSha
        currentClientId = history.state.currentClientId
        currentPictureIndex = history.state.currentPictureIndex || 0

        syncUi()
    }
    else {
        fromHash()

        publishHistoryState()

        if (window.location.hash && window.location.hash.startsWith('#') && window.location.hash.length > 10 && window.location.hash != '#null')
            el('#optional').style.display = 'none'

        syncUi()
    }

    function fromHash() {
        if (window.location.hash && window.location.hash.startsWith('#') && window.location.hash != '#null') {
            currentDirectoryDescriptorSha = window.location.hash.substr(1)
            currentClientId = null

            currentPictureIndex = -1
            let dashIndex = currentDirectoryDescriptorSha.indexOf('-')
            if (dashIndex >= 0) {
                currentPictureIndex = parseInt(currentDirectoryDescriptorSha.substr(dashIndex + 1))
                currentDirectoryDescriptorSha = currentDirectoryDescriptorSha.substr(0, dashIndex)
            }
        }
    }

    async function syncUi() {
        if (currentPictureIndex < 0) {
            if (document.webkitFullscreenElement != null && document.webkitFullscreenElement != el('#images-container')) {
                document.webkitExitFullscreen()
            }

            el('#image-full-container').style.display = 'none'
            el('#images-container').style.display = 'block'
        }
        else {
            if (document.webkitFullscreenElement != null && document.webkitFullscreenElement != el('#image-full-container')) {
                document.webkitExitFullscreen()
            }

            el('#image-full-container').style.display = 'block'
            el('#images-container').style.display = 'none'
        }

        if (currentDirectoryDescriptorSha != displayedDirectoryDescriptorSha)
            await showDirectory(currentDirectoryDescriptorSha)
        if (currentClientId != displayedClientId)
            await showRef(currentClientId)
        if (currentPictureIndex != displayedPictureIndex)
            await showPicture(currentPictureIndex)

        displayedDirectoryDescriptorSha = currentDirectoryDescriptorSha
        displayedClientId = currentClientId
        displayedPictureIndex = currentPictureIndex
    }
</script>

</html>