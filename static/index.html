<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Hexa-Backup Store</title>
    <base href="/public">
    <script src="/public/mime-types.js"></script>
    <style>
        body {
            position: absolute;
            top: 0px;
            left: 0;
            right: 0;
            bottom: 0;
            margin: 0;
            padding: 0;

            display: flex;
            overflow-x: auto;
        }

        #directoryContent {
            display: flex;
        }

        #menu{
            overflow: auto;
            flex-grow: 0;
            flex-shrink: 0;
            padding:.5em;
        }

        #menu.hide-optional > #optional {
            display:none;
        }

        #directories,
        #files {
            font-family: monospace;
            overflow: auto;
            flex-grow: 0;
            flex-shrink: 0;
            padding:.5em;
        }

        #extras {
            overflow: auto;
            flex-grow: 1;
            min-width: 10em;
        }

        #extras:-webkit-full-screen {
            display :block;
            width :100vh;
            height :100vw;
            max-width :inherit;
        }

        .small {
            font-size: .8em;
            color: #333;
        }

        #images-container {
            overflow: auto;
            height: 100vh;
            position: relative;
        }

        #image-full-container {
            overflow: auto;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        .image-full{
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        @media screen and (max-width: 1215px) {
            body {
                flex-flow: column;
            }

            #extras {
                flex-shrink: 0;
            }

            img {
                width: 50vw;
            }

            #images {
                display: flex;
                flex-flow: row;
                flex-wrap: wrap;
                justify-content: space-around;
            }
        }
    </style>
</head>

<body>
    <div id="menu">
        <button id="fullScreen">full screen</button><br />
        <button onclick='el("#menu").classList.toggle("hide-optional")'>show/hide menu</button>

        <div id="optional">
            <h2>Sources</h2>
            <div id="refs-list"></div>

            <h2>Current</h2>
            <b><span id=refName></span></b><br><br>
            commit history
            <div id="commitHistory"></div>

            <h2>Settings</h2>
            <label>extended <input type="checkbox" id="extended"></label>

            <h2>Status</h2>
            <span id="status"></span>
        </div>
    </div>
    <div id="directories"></div>
    <div id="files"></div>
    <div id="extras">
        <div id="images-container">
            <div id="images"></div>
        </div>
    </div>
    <div id="image-full-container"></div>
</body>

<script>
    let EXTENDED = false

    let currentClientId = null
    let currentDirectoryDescriptorSha = null
    let imagesPool = []

    const wait = (ms) => {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve()
            }, ms)
        })
    }

    let el = (id) => document.querySelector(id)

    const DATE_DISPLAY_OPTIONS = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    }
    const displayDate = date => (typeof date === 'number' ? new Date(date) : date).toLocaleString('fr', DATE_DISPLAY_OPTIONS)

    let lastPushedHistoryState = null
    const updateHistoryState = () => {
        let footprint = `${currentDirectoryDescriptorSha}#${currentClientId}`
        if (footprint != lastPushedHistoryState) {
            lastPushedHistoryState = footprint
            history.pushState({ currentDirectoryDescriptorSha, currentClientId }, `directory ${currentDirectoryDescriptorSha}`, `/public/#${currentDirectoryDescriptorSha}`)
        }
    }

    async function goDirectory(directoryDescriptorSha) {
        currentDirectoryDescriptorSha = directoryDescriptorSha
        updateHistoryState()
        showDirectory(currentDirectoryDescriptorSha)
    }

    async function goRef(ref) {
        let oldClientId = currentClientId
        currentClientId = ref
        if (currentClientId != oldClientId) {
            currentDirectoryDescriptorSha = await showRef(ref)
            showDirectory(currentDirectoryDescriptorSha)
        }
        else {
            await showRef(ref)
        }
        updateHistoryState()
    }

    let loaders = []

    let startLoading = (text) => {
        loaders.push(text)
        el('#status').innerHTML = loaders.join('<br>')
        return () => {
            loaders.splice(loaders.indexOf(text), 1)
            el('#status').innerHTML = loaders.join('<br>')
        }
    }

    async function showDirectory(directoryDescriptorSha) {
        el('#directories').innerHTML = ''
        el('#files').innerHTML = ''
        el('#images').innerHTML = ''

        if (!directoryDescriptorSha)
            return

        let finishLoading = startLoading(`loading directory descriptor ${directoryDescriptorSha.substr(0, 7)}`)
        let directoryDescriptor = await fetchDirectoryDescriptor(directoryDescriptorSha)
        finishLoading()

        if (!directoryDescriptor || !directoryDescriptor.files) {
            el('#directories').innerHTML = `error fetching ${directoryDescriptorSha}`
            return
        }

        let files = directoryDescriptor.files

        console.log(`entry files+dirs ${directoryDescriptorSha} = ${directoryDescriptor.files.length}`)

        finishLoading = startLoading(`listing directories`)
        let directoriesContent = files
            .filter(file => file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => EXTENDED ?
                `<div><span class='small'>${displayDate(file.lastWrite)} ${file.contentSha ? file.contentSha.substr(0, 7) : '-'}</span> <a href='#' onclick='event.preventDefault() || goDirectory("${file.contentSha}")'>${file.name}</a></div>` :
                `<div><a href='#' onclick='event.preventDefault() || goDirectory("${file.contentSha}")'>${file.name}</a></div>`)
        if (directoriesContent.length) {
            el('#directories').style.display = 'block'
            el('#directories').innerHTML = `<h2>${directoriesContent.length} Directories</h2>` + directoriesContent.join('')
        }
        else {
            el('#directories').style.display = 'none'
        }
        finishLoading()

        await wait(1)

        let images = []

        finishLoading = startLoading(`listing files`)
        let filesContent = files
            .filter(file => !file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => {
                let mimeTypes = ['application/octet-stream']
                let pos = file.name.lastIndexOf('.')
                if (pos >= 0) {
                    let extension = file.name.substr(pos + 1).toLocaleLowerCase()
                    if (extension in MimeTypes) {
                        mimeTypes.push(MimeTypes[extension])
                    }
                }

                let links = mimeTypes.map((mimeType, index) => `[<a href='/sha/${file.contentSha}/content?type=${mimeType}${index == 0 ? `&fileName=${file.name}` : ''}' >${EXTENDED ? mimeType : (index == 0 ? 'dl' : (mimeType.indexOf('/') ? mimeType.substr(mimeType.indexOf('/') + 1) : mimeType))}</a>]`).join(' ')

                let imageHtml = EXTENDED ?
                    `<span class='small'>${displayDate(file.lastWrite)} ${file.contentSha ? file.contentSha.substr(0, 7) : '-'}</span> ${file.name} <span class='small'>${file.size} ${links}</span>` :
                    `${file.name} <span class='small'>${links}</span>`

                mimeTypes.filter(t => t.startsWith('image/')).forEach(mimeType => {
                    images.push({ sha: file.contentSha, mimeType: mimeType, fileName: file.name })
                })

                return `<div>${imageHtml}</div>`
            })
        if (filesContent.length) {
            el('#files').style.display = 'block'
            el('#files').innerHTML = `<h2>${filesContent.length} Files</h2>` + filesContent.join('')
        }
        else {
            el('#files').style.display = 'none'
        }
        finishLoading()

        await wait(1)

        imagesPool = images
        restartImagesPool()
    }

    const maxImagesSeen = 100
    const imagesStep = 100

    let infiniteScrollerStop = null

    async function restartImagesPool() {
        if (infiniteScrollerStop) {
            infiniteScrollerStop()
            infiniteScrollerStop = null
        }

        if (imagesPool.length) {
            el('#images').innerHTML = ''
            infiniteScrollerStop = infiniteScroll(imagesPool,
                ({ sha, mimeType, fileName }, index) => `<img onclick='showPicture(${index})' src="/sha/${sha}/plugins/image/thumbnail?type=${mimeType}"/>`,
                el('#images-container'),
                el('#images'))
        }
        else {
            el('#images').innerHTML = '<i class="small">no picture in this folder</i>'
            // <a href='/sha/${sha}/content?type=${mimeType}'></a>
        }
    }

    async function showPicture(index) {
        let { sha, mimeType, fileName } = imagesPool[index]
        el('#image-full-container').innerHTML += `<div style='position:absolute;top:0;left:0;bottom:0;right:0;background-color: white;text-align: center;'><img class='image-full' src='/sha/${sha}/content?type=${mimeType}'/></div>`
        el('#image-full-container').innerHTML += `<div style='position:absolute;bottom:0;'><button>&lt;</button><button>&gt;</button></div>`
    }

    async function showRef(ref) {
        el('#refName').innerText = ref || ''
        el('#commitHistory').innerHTML = ''

        if (!ref)
            return null

        let clientState = await (await fetch(`/refs/${ref}`)).json()
        if (!clientState)
            return null

        let commitSha = clientState.currentCommitSha
        let firstDirectoryDescriptorSha = null

        let finishLoading = startLoading(`loading commit history`)

        while (commitSha != null) {
            let commit = await fetchCommit(commitSha)
            if (!commit)
                break

            let date = new Date(commit.commitDate)
            let directoryDescriptorSha = commit.directoryDescriptorSha
            if (directoryDescriptorSha) {
                if (!firstDirectoryDescriptorSha)
                    firstDirectoryDescriptorSha = directoryDescriptorSha
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} ${displayDate(date)} - <a href='#' onclick='event.preventDefault() || goDirectory("${directoryDescriptorSha}")'>${directoryDescriptorSha.substr(0, 7)}</a></div>`
            } else {
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} no directory descriptor in commit !</div>`
            }

            commitSha = commit.parentSha
        }

        finishLoading()

        return firstDirectoryDescriptorSha
    }

    async function fetchCommit(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    async function fetchDirectoryDescriptor(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    function infiniteScroll(db, domCreator, scrollContainer, scrollContent) {
        let nextElementToInsert = 0
        let poolSize = 5
        let stopped = false
        let waitContinueResolver = null

        async function run() {
            const shouldAdd = () => {
                console.log(`shouldAdd ${scrollContent.lastChild.offsetTop} ${scrollContainer.scrollTop} ${scrollContainer.offsetHeight}`)
                return scrollContent.lastChild.offsetTop - (scrollContainer.offsetHeight / 1) <= scrollContainer.scrollTop + scrollContainer.offsetHeight
            }

            const scrollListener = event => {
                if (waitContinueResolver && shouldAdd()) {
                    let r = waitContinueResolver
                    waitContinueResolver = null
                    r()
                }
            }
            scrollContainer.addEventListener('scroll', scrollListener)

            stopped = false
            while (!stopped) {
                if (nextElementToInsert >= db.length)
                    break

                let index = nextElementToInsert++
                let elem = db[index]

                scrollContent.innerHTML += domCreator(elem, index)

                if (nextElementToInsert % poolSize == 0) {
                    await wait(150)

                    if (!shouldAdd())
                        await new Promise(resolve => waitContinueResolver = resolve)
                }
            }

            scrollContainer.removeEventListener('scroll', scrollListener)
        }

        function stop() {
            stopped = true
            if (waitContinueResolver) {
                waitContinueResolver()
                waitContinueResolver = null
            }
        }

        run()

        return stop
    }

    window.addEventListener('load', async () => {
        let resp = await fetch('/refs')
        let refs = (await resp.json()).filter(e => e.startsWith('CLIENT_')).map(e => e.substr(7))
        el('#refs-list').innerHTML = refs.map(ref => `<a href='#' onclick='event.preventDefault() || goRef("${ref}")'>${ref}</a>`).join('<br/>')
    })

    el('#fullScreen').addEventListener('click', () => {
        el('#extras').webkitRequestFullScreen()
    })

    el('#extended').addEventListener('input', () => {
        EXTENDED = !!el('#extended').checked

        showDirectory(currentDirectoryDescriptorSha)
        showRef(currentClientId)
    })

    window.onpopstate = function (event) {
        currentDirectoryDescriptorSha = event.state.currentDirectoryDescriptorSha
        currentClientId = event.state.currentClientId

        showDirectory(currentDirectoryDescriptorSha)
        showRef(currentClientId)
    }

    if (history.state) {
        currentDirectoryDescriptorSha = history.state.currentDirectoryDescriptorSha
        currentClientId = history.state.currentClientId

        showDirectory(currentDirectoryDescriptorSha)
        showRef(currentClientId)
    }
    else if (window.location.hash && window.location.hash.startsWith('#') && window.location.hash != '#null') {
        currentDirectoryDescriptorSha = window.location.hash.substr(1)
        currentClientId = null

        el('#optional').style.display = 'none'

        showDirectory(currentDirectoryDescriptorSha)
        showRef(currentClientId)

        updateHistoryState()
    }
</script>

</html>