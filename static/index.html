<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Hexa-Backup Store</title>
    <base href="/public">
    <script src="/public/mime-types.js"></script>
    <style>
        body {
            display: flex;
            position: absolute;
            top: 0px;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .aside {
            overflow: auto;
        }

        #directoryContent {
            display: flex;
        }

        #directories,
        #files {
            font-family: monospace;
            overflow: auto;
            flex-grow: 1;
        }

        #directories {
            flex-shrink: 1;
        }

        #extras {
            max-width: 15em;
            overflow: auto;
        }

        .full {
            display: flex;
            flex-flow: column;
            flex-grow: 1;
        }

        .small {
            font-size: .8em;
            color: #333;
        }
    </style>
</head>

<body>
    <div class="aside">
        <h2>Sources</h2>
        <div id="refs-list"></div>

        <h2>Current</h2>
        <b><span id=refName></span></b><br><br>
        commit history
        <div id="commitHistory"></div>

        <h2>Status</h2>
        <span id="status"></span>
    </div>
    <div class="full">
        <h2>Directory content:</h2>
        <div id="directoryContent">
            <div id="directories"></div>
            <div id="files"></div>
            <div id="extras"></div>
        </div>
    </div>
</body>

<script>
    let currentClientId = null
    let currentDirectoryDescriptorSha = null
    let imagesPool = []
    let imagesPoolStart = 0

    const wait = (ms) => {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve()
            }, ms)
        })
    }

    let el = (id) => document.querySelector(id)

    const DATE_DISPLAY_OPTIONS = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    }
    const displayDate = date => (typeof date === 'number' ? new Date(date) : date).toLocaleString('fr', DATE_DISPLAY_OPTIONS)

    let lastPushedHistoryState = null
    const updateHistoryState = () => {
        let footprint = `${currentDirectoryDescriptorSha}#${currentClientId}`
        if (footprint != lastPushedHistoryState) {
            lastPushedHistoryState = footprint
            history.pushState({ currentDirectoryDescriptorSha, currentClientId }, `directory ${currentDirectoryDescriptorSha}`, `/public/#${currentDirectoryDescriptorSha}`)
        }
    }

    async function goDirectory(directoryDescriptorSha) {
        currentDirectoryDescriptorSha = directoryDescriptorSha
        updateHistoryState()
        showDirectory(currentDirectoryDescriptorSha)
    }

    async function goRef(ref) {
        if (currentClientId != ref) {
            currentDirectoryDescriptorSha = null
            showDirectory(null)
        }
        currentClientId = ref
        updateHistoryState()
        showRef(currentClientId)
    }

    let loaders = []

    let startLoading = (text) => {
        loaders.push(text)
        el('#status').innerHTML = loaders.join('<br>')
        return () => {
            loaders.splice(loaders.indexOf(text), 1)
            el('#status').innerHTML = loaders.join('<br>')
        }
    }

    async function showDirectory(directoryDescriptorSha) {
        el('#directories').innerHTML = ''
        el('#files').innerHTML = ''
        el('#extras').innerHTML = ''

        if (!directoryDescriptorSha)
            return

        let finishLoading = startLoading(`loading directory descriptor ${directoryDescriptorSha.substr(0, 7)}`)
        let directoryDescriptor = await fetchDirectoryDescriptor(directoryDescriptorSha)
        finishLoading()

        if (!directoryDescriptor || !directoryDescriptor.files) {
            el('#directories').innerHTML = `error fetching ${directoryDescriptorSha}`
            return
        }

        let files = directoryDescriptor.files

        finishLoading = startLoading(`listing directories`)
        el('#directories').innerHTML = files
            .filter(file => file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => `<div><span class='small'>${displayDate(file.lastWrite)} ${file.contentSha.substr(0, 7)}</span> <a href='#' onclick='event.preventDefault() || goDirectory("${file.contentSha}")'>${file.name}</a></div>`)
            .join('')
        finishLoading()

        await wait(1)

        let images = []

        finishLoading = startLoading(`listing files`)
        el('#files').innerHTML = files
            .filter(file => !file.isDirectory)
            .sort((a, b) => {
                if (a.name > b.name)
                    return 1
                if (a.name < b.name)
                    return -1
                return 0
            })
            .map(file => {
                let mimeTypes = ['application/octet-stream']
                let pos = file.name.lastIndexOf('.')
                if (pos >= 0) {
                    let extension = file.name.substr(pos + 1).toLocaleLowerCase()
                    if (extension in MimeTypes) {
                        mimeTypes.push(MimeTypes[extension])
                    }
                }

                let links = mimeTypes.map((mimeType, index) => `[<a href='/sha/${file.contentSha}/content?type=${mimeType}${index == 0 ? `&fileName=${file.name}` : ''}' >${mimeType}</a>]`).join(' ')

                let imageHtml = `<span class='small'>${displayDate(file.lastWrite)} ${file.contentSha.substr(0, 7)}</span> ${file.name} <span class='small'>${file.size} ${links}</span>`

                mimeTypes.filter(t => t.startsWith('image/')).forEach(mimeType => {
                    images.push({ sha: file.contentSha, mimeType: mimeType, fileName: file.name })
                })

                return `<div>${imageHtml}</div>`
            })
            .join('')
        finishLoading()

        await wait(1)

        imagesPool = images
        restartImagesPool()
    }

    async function restartImagesPool() {
        imagesPoolStart = 0
        finishLoading = startLoading(`inserting images`)
        let images = imagesPool.slice(imagesPoolStart, 100)
        el('#extras').innerHTML = images.map(({ sha, mimeType, fileName }) => `<a href='/sha/${sha}/content?type=${mimeType}'><img src="/sha/${sha}/plugins/image/thumbnail?type=${mimeType}"/></a>`)
            .join('')
        if (imagesPool.length > 100)
            el('#extras').innerHTML += '<div>There are more...</div>'
        finishLoading()
    }

    async function showRef(ref) {
        el('#refName').innerText = ref || ''
        el('#commitHistory').innerHTML = ''

        if (!ref)
            return

        let clientState = await (await fetch(`/refs/${ref}`)).json()
        if (!clientState)
            return

        let commitSha = clientState.currentCommitSha
        let firstDirectoryDescriptorSha = null

        let finishLoading = startLoading(`loading commit history`)

        while (commitSha != null) {
            let commit = await fetchCommit(commitSha)
            if (!commit)
                break

            let date = new Date(commit.commitDate)
            let directoryDescriptorSha = commit.directoryDescriptorSha
            if (directoryDescriptorSha) {
                if (!firstDirectoryDescriptorSha)
                    firstDirectoryDescriptorSha = directoryDescriptorSha
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} ${displayDate(date)} - <a href='#' onclick='event.preventDefault() || goDirectory("${directoryDescriptorSha}")'>${directoryDescriptorSha.substr(0, 7)}</a></div>`
            } else {
                el('#commitHistory').innerHTML += `<div>${commitSha.substr(0, 7)} no directory descriptor in commit !</div>`
            }

            commitSha = commit.parentSha
        }

        finishLoading()

        if (firstDirectoryDescriptorSha && !currentDirectoryDescriptorSha) {
            showDirectory(firstDirectoryDescriptorSha)
        }
    }

    async function fetchCommit(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    async function fetchDirectoryDescriptor(sha) {
        let mimeType = 'text/json'
        let content = await fetch(`/sha/${sha}/content?type=${mimeType}`)
        return await content.json()
    }

    window.addEventListener('load', async () => {
        let resp = await fetch('/refs')
        let refs = (await resp.json()).filter(e => e.startsWith('CLIENT_')).map(e => e.substr(7))
        el('#refs-list').innerHTML = refs.map(ref => `<a href='#' onclick='event.preventDefault() || goRef("${ref}")'>${ref}</a>`).join('<br/>')
    })

    window.onpopstate = function (event) {
        currentDirectoryDescriptorSha = event.state.currentDirectoryDescriptorSha
        currentClientId = event.state.currentClientId

        console.log(`pop ${JSON.stringify(event.state)}`)
        showDirectory(event.state.currentDirectoryDescriptorSha)
        showRef(event.state.currentClientId)
    }

    if (history.state) {
        currentDirectoryDescriptorSha = history.state.currentDirectoryDescriptorSha
        currentClientId = history.state.currentClientId

        console.log(`history ${JSON.stringify(history.state)}`)
        showDirectory(history.state.currentDirectoryDescriptorSha)
        showRef(history.state.currentClientId)
    }
</script>

</html>